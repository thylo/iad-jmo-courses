---
title: JavaScript - Fondamentaux
description: Référence théorique pour comprendre JavaScript et le DOM
---

import { Card, CardGrid } from '@astrojs/starlight/components';

Cette page est une **référence théorique**. Elle ne doit pas être lue d'un coup. Tu la consultes quand tu bloques sur un concept lors des exercices.

**Pour apprendre en pratiquant →** [Clickclickclick - La pratique](clickclickclick-pratique)

---

## Comment fonctionne une page web

Quand tu accèdes à un site, voici ce qui se passe :

**1. Tu entres une URL ou tu cliques sur un lien**
```
https://example.com
```
Le navigateur envoie une requête HTTP au serveur : "Je veux la page example.com"

**2. Le serveur répond avec un code de statut HTTP**
Le serveur dit si tout va bien ou s'il y a un problème :
- `200` → OK, la page existe et je te l'envoie
- `404` → Page not found (la page n'existe pas)
- `500` → Erreur serveur

Si tout va bien (200), le serveur envoie le fichier HTML.

**3. Le navigateur déchiffre le HTML et crée le DOM**
Le navigateur lit le HTML et construit une structure en mémoire appelée **DOM** (Document Object Model). C'est comme assembler un arbre avec tous les éléments de la page dedans.

**4. Le navigateur applique le CSS**
Il charge et applique les styles (couleurs, tailles, mises en page).

**5. La page s'affiche**
Elle devient visible à l'écran avec la structure HTML et le style CSS.

**6. JavaScript s'exécute**
Quand le navigateur rencontre un `<script>`, il exécute le JavaScript. À ce moment, JavaScript a accès au DOM et peut le modifier.

**C'est le point clé : le DOM n'est pas figé. C'est un objet vivant qu'on peut modifier via JavaScript.**

Quand JavaScript change le DOM (texte, couleur, éléments), les changements s'affichent **immédiatement** dans le navigateur sans recharger la page.

---

## Le DOM : une représentation vivante du HTML

Le **DOM** (Document Object Model) est une structure en mémoire qui représente le HTML actuellement affiché.

En HTML, tu as ça :
```html
<button id="mon-bouton">Clique-moi</button>
```

Quand la page charge, le DOM crée une version en mémoire de ce bouton. **Tu peux alors modifier cet objet**, et les changements s'affichent **instantanément** dans le navigateur :

```javascript
const btn = document.getElementById('mon-bouton');

// À partir de là, le bouton change EN TEMPS RÉEL
btn.textContent = 'Cliqué!';
btn.style.backgroundColor = 'red';
btn.classList.add('actif');
```

Le HTML original du fichier ne change pas. C'est juste la représentation en mémoire (le DOM) qui change. Et tant que la page reste ouverte, tu peux continuer à le modifier.

---

## Window vs Document

Deux objets importants à ne pas confondre :

- **`window`** = la fenêtre du navigateur (tout ce qui l'entoure). C'est l'objet global.
- **`document`** = le contenu HTML à l'intérieur de la fenêtre.

```javascript
// Window : la fenêtre du navigateur
window.alert('Alerte!');
window.innerWidth;  // Largeur de la fenêtre

// Document : le contenu HTML
document.getElementById('btn');
document.body;
```

En pratique, tu utiliseras presque toujours `document` pour manipuler le contenu.

---

## Les trois opérations essentielles

### Sélectionner un élément

Avant de modifier, tu dois d'abord accéder à l'élément via le DOM.

```javascript
// Par ID (unique dans la page)
const btn = document.getElementById('mon-bouton');

// Par classe ou sélecteur CSS
const btn = document.querySelector('.bouton');
const tous = document.querySelectorAll('.bouton');
```

**Différence :**
- `getElementById()` → retourne **un** élément (ou null)
- `querySelector()` → retourne **le premier** élément qui match
- `querySelectorAll()` → retourne **tous** les éléments qui match (une liste)

---

### Écouter les événements

Un **événement** est une action de l'utilisateur que tu peux détecter.

Événements courants :
- `click` → clic de souris
- `mousemove` → mouvement de souris
- `mousedown` / `mouseup` → appui / relâchement
- `dblclick` → double-clic
- `keydown` / `keyup` → appui sur une touche

```javascript
const btn = document.getElementById('test');

btn.addEventListener('click', function() {
  console.log('Clic détecté');
});
```

L'objet `event` contient des infos sur l'action :
- `event.clientX, event.clientY` → position de la souris
- `event.target` → l'élément cliqué
- `event.type` → le type d'événement (click, mousemove, etc.)
- `event.key` → la touche appuyée (pour keyboard events)

```javascript
document.addEventListener('mousemove', function(event) {
  console.log('Souris à', event.clientX, event.clientY);
});
```

---

### Modifier le DOM

Quand un événement se déclenche, tu modifies le DOM. Les changements sont visibles **immédiatement** :

```javascript
// Changer le texte
btn.textContent = 'Nouveau texte';

// Changer l'HTML complet
btn.innerHTML = '<strong>Gras</strong>';

// Changer un style
btn.style.backgroundColor = 'blue';

// Ajouter/retirer une classe
btn.classList.add('actif');
btn.classList.remove('actif');
btn.classList.toggle('actif');  // Ajoute si absent, retire si présent

// Supprimer un élément
btn.remove();  // Le bouton disparaît de la page
```

**Important :** `textContent` = texte brut. `innerHTML` = texte + balises HTML. Préfère `textContent` sauf si tu dois vraiment ajouter des balises.

---

## Créer et ajouter des éléments dynamiquement

Tu peux créer de nouveaux éléments à partir de rien :

```javascript
// Créer un nouvel élément
const newDiv = document.createElement('div');

// Ajouter du contenu
newDiv.textContent = 'Je suis nouveau!';

// L'ajouter à la page
document.body.appendChild(newDiv);  // Ajoute la div à la fin du body
```

**`createElement()`** → crée un élément vide en mémoire (pas encore visible).
**`appendChild()`** → attache l'élément à un parent (le rend visible).

```javascript
// Exemple : ajouter un bouton quand on clique
btn.addEventListener('click', function() {
  const newButton = document.createElement('button');
  newButton.textContent = 'Nouveau bouton';
  document.body.appendChild(newButton);
});
```

---

## Variables : stocker des données

Une **variable** est un conteneur qui stocke une valeur.

```javascript
// Créer une variable
let count = 0;

// Lire la valeur
console.log(count);  // 0

// Modifier la valeur
count = count + 1;
count++;  // Raccourci : ajoute 1

// Utiliser la valeur
btn.textContent = 'Clics : ' + count;
```

**Trois mots-clés :**
- `let` → variable qui peut changer
- `const` → variable qui ne change pas (constante)
- `var` → ancienne syntaxe (à éviter)

**Règle simple :** Utilise `let` ou `const`. Préfère `const` (plus sûr). N'utilise `let` que si tu dois changer la valeur.

---

## Template strings : construire du texte

Quand tu veux insérer des variables dans du texte, utilise les **template strings** :

```javascript
let count = 5;
let nom = 'Alice';

// Ancienne manière (concaténation)
const message1 = 'Bonjour ' + nom + ', tu as cliqué ' + count + ' fois';

// Nouvelle manière (template strings) — plus lisible
const message2 = `Bonjour ${nom}, tu as cliqué ${count} fois`;

console.log(message2); // "Bonjour Alice, tu as cliqué 5 fois"
```

Les template strings utilisent les **backticks** (`` ` ``) et les `${}` pour insérer des variables.

---

## Fonctions : réutiliser du code

Une **fonction** est un bloc de code réutilisable.

```javascript
// Définir une fonction
function saluer() {
  console.log('Bonjour!');
}

// L'appeler (exécuter le code)
saluer();  // Affiche: "Bonjour!"
saluer();  // Affiche: "Bonjour!" (de nouveau)
```

### Fonctions avec paramètres

Une fonction peut recevoir des données :

```javascript
// Définir une fonction avec des paramètres
function saluer(nom, age) {
  console.log(`Bonjour ${nom}, tu as ${age} ans`);
}

// Appeler la fonction avec des arguments
saluer('Alice', 25);      // Affiche: "Bonjour Alice, tu as 25 ans"
saluer('Bob', 30);        // Affiche: "Bonjour Bob, tu as 30 ans"
```

**Vocabulaire :**
- **Paramètres** = variables dans la définition de la fonction (`nom`, `age`)
- **Arguments** = valeurs qu'on passe quand on l'appelle (`'Alice'`, `25`)

---

## Appel vs référence

C'est **la plus grande confusion chez les débutants**.

```javascript
function dire(texte) {
  console.log(texte);
}

// ❌ ERREUR: Appeler la fonction (exécute le code tout de suite)
const x = dire('Bonjour');  // "Bonjour" s'affiche IMMÉDIATEMENT

// ✅ CORRECT: Référencer la fonction (pas d'appel)
const x = dire;    // Rien ne s'affiche. Tu juste la référence.
```

**La différence :**
- `dire` = référence à la fonction (la fonction elle-même)
- `dire()` = appel de la fonction (exécute le code)

### Avec `addEventListener`

```javascript
function maFonction() {
  console.log('Bouton cliqué!');
}

// ❌ ERREUR: Appel de fonction
btn.addEventListener('click', maFonction());
// maFonction() s'exécute IMMÉDIATEMENT (avant le clic)

// ✅ CORRECT: Référence à la fonction
btn.addEventListener('click', maFonction);
// maFonction s'exécute QUAND tu cliques
```

`addEventListener` attend une **fonction**. Si tu l'appelles avec `()`, tu passes le résultat, pas la fonction elle-même.

### Si la fonction a besoin d'arguments

```javascript
function afficher(message) {
  console.log(message);
}

// ❌ ERREUR
btn.addEventListener('click', afficher('Cliqué!'));
// afficher() s'exécute immédiatement

// ✅ CORRECT: Wrapper dans une fonction anonyme
btn.addEventListener('click', function() {
  afficher('Cliqué!');
});
// Quand tu cliques, la fonction anonyme s'exécute, qui elle appelle afficher()
```

---

## Conditions : ramifier l'histoire

Les `if/else` permettent de prendre des décisions :

```javascript
let age = 20;

if (age >= 18) {
  console.log('Tu es majeur');
} else {
  console.log('Tu es mineur');
}
```

Opérateurs de comparaison :
- `===` → égal (strictement)
- `!==` → pas égal
- `>`, `<` → plus grand, plus petit
- `>=`, `<=` → plus grand ou égal, plus petit ou égal

**Important :** Utilise `===` (pas `==`). C'est plus strict et évite les bugs.

```javascript
// ❌ À éviter
if (count == 5) { ... }

// ✅ Préfère
if (count === 5) { ... }
```

Combiner des conditions :

```javascript
if (count < 5 && age > 18) {
  // QUAND count est moins de 5 ET age est plus de 18
  console.log('Condition 1');
} else if (count < 5 || age > 18) {
  // QUAND count est moins de 5 OU age est plus de 18
  console.log('Condition 2');
} else {
  // Sinon
  console.log('Rien');
}
```

**`&&`** = ET (les deux doivent être vrais)
**`||`** = OU (au moins une doit être vraie)

---

## Quand s'exécute le JavaScript

C'est crucial : **le JavaScript s'exécute au moment où tu l'appelles, pas plus tard.**

### Problème typique : DOM pas encore chargé

```html
<!DOCTYPE html>
<html>
<head>
  <script>
    const btn = document.getElementById('btn');
    btn.addEventListener('click', ...); // ERREUR! btn est null
  </script>
</head>
<body>
  <button id="btn">Mon bouton</button>
</body>
</html>
```

Pourquoi l'erreur ? Le script dans `<head>` s'exécute **avant que le navigateur déchiffre le `<body>`**. À ce moment, le bouton n'existe pas encore. `getElementById('btn')` retourne `null`.

### Solution 1 : Mettre le script à la fin du `<body>`

```html
<!DOCTYPE html>
<html>
<head>
  <title>Ma page</title>
</head>
<body>
  <button id="btn">Mon bouton</button>

  <!-- Script à la fin, après tous les éléments -->
  <script>
    const btn = document.getElementById('btn');
    btn.addEventListener('click', ...); // OK!
  </script>
</body>
</html>
```

À ce moment, tous les éléments HTML existent déjà.

### Solution 2 : Attendre que le DOM soit chargé

```html
<!DOCTYPE html>
<html>
<head>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Ce code s'exécute APRÈS que le DOM soit complètement chargé
      const btn = document.getElementById('btn');
      btn.addEventListener('click', ...); // OK!
    });
  </script>
</head>
<body>
  <button id="btn">Mon bouton</button>
</body>
</html>
```

L'événement `DOMContentLoaded` se déclenche quand tous les éléments HTML ont été chargés. C'est sûr à ce moment.

---

## Boucles : répéter du code

Les boucles permettent de faire la même chose plusieurs fois :

```javascript
// Boucle : affiche les nombres de 0 à 4
for (let i = 0; i < 5; i++) {
  console.log(i);
}

// Résultat :
// 0
// 1
// 2
// 3
// 4
```

**Anatomie :**
- `let i = 0` → initialiser : où on commence
- `i < 5` → condition : tant que c'est vrai, continuer
- `i++` → incrémenter : ajouter 1 à chaque itération

**Exemple : créer plusieurs boutons**

```javascript
for (let i = 1; i <= 5; i++) {
  const btn = document.createElement('button');
  btn.textContent = 'Bouton ' + i;
  document.body.appendChild(btn);
}
```

---

## Pièges courants

### 1. `getElementById()` retourne `null`

**Problème :**
```javascript
const btn = document.getElementById('btn');
btn.addEventListener('click', ...); // ERREUR: Cannot read property 'addEventListener' of null
```

**Causes possibles :**
- L'ID n'existe pas dans le HTML
- Le script s'exécute **avant que l'élément soit chargé**
- Typo dans l'ID (ex: `getElementById('button')` mais le HTML a `id="btn"`)

**Solution :** Vérifie que:
- L'ID est correct et unique dans la page
- Le script s'exécute **après** que l'élément soit créé
- La console (F12) te montre l'erreur exacte

---

### 2. Mélanger `textContent` et `innerHTML`

**Problème :**
```javascript
// Ceci ajoute du texte brut
btn.textContent = '<strong>Gras</strong>';  // Affiche littéralement: "<strong>Gras</strong>"

// Ceci ajoute du HTML
btn.innerHTML = '<strong>Gras</strong>';   // Affiche: **Gras** (en gras)
```

**Règle :**
- `textContent` = du texte simple, jamais du HTML
- `innerHTML` = du texte + balises HTML

Utilise `textContent` sauf si tu as vraiment besoin d'ajouter des balises.

---

### 3. Template strings sans backticks

**Erreur :**
```javascript
const count = 5;

// ❌ Ceci ne marche pas :
const message = "Tu as cliqué ${count} fois";  // Double quotes, pas backticks

// ✅ Correct
const message = `Tu as cliqué ${count} fois`;  // Backticks
```

**Règle :** Les template strings utilisent **backticks** (`` ` ``), pas simple ou double quotes.

---

### 4. Oublier le `function()` dans `addEventListener`

**Erreur :**
```javascript
// ❌ Faux
btn.addEventListener('click', alert('Cliqué!'));

// ✅ Correct
btn.addEventListener('click', function() {
  alert('Cliqué!');
});
```

La deuxième argument doit être une **fonction**, pas l'appel d'une fonction.

---

### 5. Confondre `=` (assigner) et `===` (comparer)

**Erreur :**
```javascript
if (count = 5) {  // ❌ Assigne count à 5 au lieu de comparer
  console.log('C\'est 5');
}

if (count === 5) {  // ✅ Compare count avec 5
  console.log('C\'est 5');
}
```

**Règle :**
- Un seul `=` → assigne une valeur
- `===` ou `==` → compare une valeur

Utilise `===` pour les comparaisons (c'est plus strict et sûr).

---

### 6. Modifier une variable et penser que ça change le DOM

**Erreur :**
```javascript
let message = 'Bonjour';
const output = document.getElementById('output');

message = 'Au revoir';
// Le DOM ne change pas! Tu as juste changé la variable.

// ✅ Correct
output.textContent = message;  // Là, le DOM change et ça s'affiche
```

**Règle :** Changer une variable JavaScript ne change pas automatiquement la page. Tu dois **explicitement modifier le DOM** avec `.textContent`, `.innerHTML`, `.style`, etc.

---

### 7. Event bubbling (un événement "remonte")

**Problème :**
```html
<div onclick="console.log('Div cliquée')">
  <button onclick="console.log('Bouton cliqué')">Clique-moi</button>
</div>
```

Quand tu cliques sur le bouton, tu vois :
```
Bouton cliqué
Div cliquée
```

Pourquoi ? L'événement du bouton "remonte" à son parent (la div). C'est le **bubbling**.

**Solution :** Si tu veux empêcher ça :
```javascript
btn.addEventListener('click', function(event) {
  event.stopPropagation();  // Empêche l'événement de remonter
});
```

Mais **la plupart du temps, tu ne dois pas t'en soucier**.

---

## En résumé : les briques du code interactif

<CardGrid>
  <Card title="Sélectionner">
    `document.getElementById()`, `querySelector()`
  </Card>
  <Card title="Écouter">
    `addEventListener('click', ...)`, `addEventListener('mousemove', ...)`
  </Card>
  <Card title="Modifier">
    `.textContent`, `.style`, `.classList.add()`, `.appendChild()`
  </Card>
  <Card title="Stocker">
    `let`, `const` pour garder en mémoire
  </Card>
</CardGrid>

Tout le code interactif suit cette logique simple : **sélectionner → écouter → modifier**.

---

## Retour à la pratique

Maintenant que tu connais les briques théoriques, retour à l'exercice :

**[Clickclickclick - La pratique →](clickclickclick-pratique)**