**Objectif :** Apprendre à rendre une page web interactive en capturant les actions de l'utilisateur (clics, mouvements souris) et en changeant le contenu à l'écran en réaction.

**Inspiration :** On va étudier https://clickclickclick.click/ du studio Moniker, puis créer notre propre version interactive.

## Concepts fondamentaux

### Comment fonctionne une page web

Quand tu ouvres une page :

1. Le navigateur **parse le HTML** et crée une structure appelée **DOM**
2. Le navigateur **applique le CSS** (couleurs, tailles, mise en page)
3. La page s'affiche
4. **JavaScript peut maintenant modifier le DOM** — et ces modifications se voient **immédiatement** dans le navigateur

C'est le point clé : **le DOM n'est pas figé. C'est un objet vivant qu'on peut changer à tout moment.**

### Le DOM : une représentation vivante du HTML

Le **DOM** (Document Object Model) est une structure en mémoire qui représente le HTML actuellement affiché.

En HTML, tu as ça :
```html
<button id="mon-bouton">Clique-moi</button>
```

Quand la page charge, le DOM crée une version en mémoire de ce bouton. **Tu peux alors modifier cet objet**, et les changements s'affichent **instantanément** dans le navigateur :

```javascript
const btn = document.getElementById('mon-bouton');

// À partir de là, le bouton change EN TEMPS RÉEL
btn.textContent = 'Cliqué!';
btn.style.backgroundColor = 'red';
btn.classList.add('actif');
```

Le HTML original du fichier ne change pas. C'est juste la représentation en mémoire (le DOM) qui change. Et tant que la page reste ouverte, tu peux continuer à le modifier.

---

## Les trois opérations essentielles

### 1. Sélectionner un élément

Avant de modifier, tu dois d'abord accéder à l'élément via le DOM.

```javascript
// Par ID (unique dans la page)
const btn = document.getElementById('mon-bouton');

// Par classe ou sélecteur CSS
const btn = document.querySelector('.bouton');
const tous = document.querySelectorAll('.bouton');
```

**Exercice 1 :** Sélectionner un élément
- Crée du HTML avec `<button id="test">Bouton</button>`
- Dans la console (F12), tape `document.getElementById('test')`
- Vérifies que ça retourne le bouton en mémoire

---

### 2. Écouter les événements

Un **événement** est une action de l'utilisateur que tu peux détecter :

- `click` → clic de souris
- `mousemove` → mouvement de souris
- `mousedown` / `mouseup` → appui / relâchement

```javascript
const btn = document.getElementById('test');

btn.addEventListener('click', function() {
  console.log('Clic détecté');
});
```

**Exercice 2 :** Écouter un événement
- Ajoute le code ci-dessus en JavaScript
- Clique le bouton
- Ouvre la console (F12) et vérifie le message

---

### 3. Modifier le DOM

Quand un événement se déclenche, tu modifies le DOM. Les changements sont visibles **immédiatement** :

```javascript
// Changer le texte
btn.textContent = 'Nouveau texte';

// Changer l'HTML complet
btn.innerHTML = '<strong>Gras</strong>';

// Changer un style
btn.style.backgroundColor = 'blue';

// Ajouter/retirer une classe
btn.classList.add('actif');
btn.classList.remove('actif');
btn.classList.toggle('actif');
```

**Exercice 3 :** Compteur de clics (modifie le DOM à chaque clic)
```javascript
let count = 0;
const btn = document.getElementById('test');

btn.addEventListener('click', function() {
  count = count + 1;
  btn.textContent = 'Cliqué ' + count + ' fois';
  // À chaque clic, le DOM change et tu vois le changement instantanément
});
```

---

## Environnement de travail

On utilise **CodePen** (https://codepen.io) pour coder et tester en direct. Tu vois le résultat du code instantanément.

---

## Comment inclure du JavaScript dans une page

Il y a trois façons d'ajouter du JavaScript à une page HTML.

### 1. Script inline (dans la balise HTML)

```html
<button onclick="alert('Cliqué!')">Mon bouton</button>
```

**Avantage :** Simple pour des trucs très courts.
**Inconvénient :** Mélange HTML et JS, pas très maintenable.

**À éviter pour les projets sérieux.**

### 2. Script externe (fichier séparé)

**index.html :**
```html
<!DOCTYPE html>
<html>
<head>
  <title>Ma page</title>
</head>
<body>
  <button id="btn">Mon bouton</button>
  <script src="script.js"></script>
</body>
</html>
```

**script.js :**
```javascript
const btn = document.getElementById('btn');
btn.addEventListener('click', function() {
  alert('Cliqué!');
});
```

**Avantage :** Séparation HTML/JS, réutilisable, plus lisible.
**C'est la méthode standard.**

### 3. Script module (ES6)

```html
<script type="module" src="script.js"></script>
```

**Avantage :** Code organisé en modules réutilisables, `import`/`export`.
**Pour les projets plus complexes.**

---

## Quand s'exécute le JavaScript

C'est crucial : **le JavaScript s'exécute au moment où tu l'appelles, pas plus tard.**

### Problème typique : DOM pas encore chargé

```html
<!DOCTYPE html>
<html>
<head>
  <script>
    const btn = document.getElementById('btn');
    btn.addEventListener('click', ...); // ERREUR! btn est null
  </script>
</head>
<body>
  <button id="btn">Mon bouton</button>
</body>
</html>
```

Pourquoi l'erreur? Le script dans `<head>` s'exécute **avant que le navigateur parse le `<body>`**. À ce moment, le bouton n'existe pas encore. `getElementById('btn')` retourne `null`.

### Solution 1 : Mettre le script à la fin du `<body>`

```html
<!DOCTYPE html>
<html>
<head>
  <title>Ma page</title>
</head>
<body>
  <button id="btn">Mon bouton</button>

  <!-- Script à la fin, après tous les éléments -->
  <script>
    const btn = document.getElementById('btn');
    btn.addEventListener('click', ...); // OK!
  </script>
</body>
</html>
```

À ce moment, tous les éléments HTML existent déjà.

### Solution 2 : Attendre que le DOM soit chargé

```html
<!DOCTYPE html>
<html>
<head>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Ce code s'exécute APRÈS que le DOM soit complètement chargé
      const btn = document.getElementById('btn');
      btn.addEventListener('click', ...); // OK!
    });
  </script>
</head>
<body>
  <button id="btn">Mon bouton</button>
</body>
</html>
```

L'événement `DOMContentLoaded` se déclenche quand tous les éléments HTML ont été chargés. C'est sûr à ce moment.

### En résumé

| Placement | Quand s'exécute | Accès au DOM? |
|-----------|-----------------|---------------|
| Dans `<head>` | Immédiatement, avant le reste | ❌ Non (les éléments n'existent pas) |
| Avant `</body>` | Quand le parser arrive au script | ✅ Oui (les éléments sont chargés) |
| Avec `DOMContentLoaded` | Après le chargement complet du HTML | ✅ Oui (garanti) |

**Pour CodePen :** CodePen gère ça automatiquement. Tu peux mettre ton JS sans te soucier de l'ordre.

---

## Les fonctions : appel vs référence

C'est **la plus grande confusion chez les débutants**. Comprendre la différence change tout.

### Qu'est-ce qu'une fonction?

Une fonction est un bloc de code réutilisable. Tu la **définis une fois**, puis tu peux la **réutiliser plusieurs fois**.

```javascript
// Définir une fonction
function saluer() {
  console.log('Bonjour!');
}

// L'appeler (exécuter le code)
saluer();  // Affiche: "Bonjour!"
saluer();  // Affiche: "Bonjour!" (de nouveau)
```

### Le piège : appeler vs référencer

C'est ici que les débutants se trompent, surtout avec `addEventListener`.

```javascript
function saluer() {
  console.log('Bonjour!');
}

// ❌ ERREUR: Appeler la fonction (exécute le code tout de suite)
const x = saluer();  // "Bonjour!" s'affiche IMMÉDIATEMENT
console.log(x);      // undefined

// ✅ CORRECT: Référencer la fonction (pas d'appel)
const x = saluer;    // Rien ne s'affiche. Tu juste la référence.
console.log(x);      // [Function: saluer]
```

**La différence :**
- `saluer` = référence à la fonction (la fonction elle-même)
- `saluer()` = appel de la fonction (exécute le code)

### Exemple avec addEventListener

```javascript
function maFonction() {
  console.log('Bouton cliqué!');
}

// ❌ ERREUR: Appel de fonction
btn.addEventListener('click', maFonction());
// maFonction() s'exécute IMMÉDIATEMENT (avant le clic)
// Rien ne se passe quand tu cliques

// ✅ CORRECT: Référence à la fonction
btn.addEventListener('click', maFonction);
// maFonction s'exécute QUAND tu cliques
```

Pourquoi? Parce que `addEventListener` attend une **fonction**. Si tu l'appelles avec `()`, tu passes le résultat de la fonction, pas la fonction elle-même.

### Les arguments : passer des données à une fonction

Une fonction peut avoir des **paramètres** (des variables qui reçoivent des données).

```javascript
// Définir une fonction avec des paramètres
function saluer(nom, age) {
  console.log(`Bonjour ${nom}, tu as ${age} ans`);
}

// Appeler la fonction avec des arguments
saluer('Alice', 25);      // Affiche: "Bonjour Alice, tu as 25 ans"
saluer('Bob', 30);        // Affiche: "Bonjour Bob, tu as 30 ans"
```

**Vocabulaire :**
- **Paramètres** = variables dans la définition de la fonction (`nom`, `age`)
- **Arguments** = valeurs qu'on passe quand on l'appelle (`'Alice'`, `25`)

### Piège : passer une fonction avec des arguments à addEventListener

Si ta fonction a besoin d'arguments, tu dois la **wrapper** dans une autre fonction :

```javascript
function afficher(message) {
  console.log(message);
}

// ❌ ERREUR: Essayer de passer des arguments directement
btn.addEventListener('click', afficher('Cliqué!'));
// afficher() s'exécute immédiatement, rien ne se passe au clic

// ✅ CORRECT: Wrapper dans une fonction anonyme
btn.addEventListener('click', function() {
  afficher('Cliqué!');
});
// Quand tu cliques, la fonction anonyme s'exécute, qui elle appelle afficher()
```

Pourquoi? Parce qu'`addEventListener` veut une fonction qui **n'a pas d'arguments**. Si tu dois passer des données, tu utilises une fonction anonyme qui enveloppe l'appel.

### Exercice 5 : Comprendre références vs appels

Prédis ce qu'il se passe dans chaque cas:

```javascript
function dire(texte) {
  console.log(texte);
}

// Cas 1 : Appel avec argument
dire('Cas 1');

// Cas 2 : Référence sans appel
dire;

// Cas 3 : Appel dans une fonction anonyme
function() {
  dire('Cas 3');
}

// Cas 4 : Appel immédiat
const resultat = dire('Cas 4');
console.log(resultat);
```

**Réponses :**
- Cas 1 → Affiche: "Cas 1"
- Cas 2 → Rien (tu références juste la fonction, sans l'exécuter)
- Cas 3 → La fonction ne s'exécute pas toute seule. Tu dois l'appeler: `function() { dire('Cas 3'); }()`
- Cas 4 → Affiche: "Cas 4", puis undefined (car `dire()` ne retourne rien)

### Résumé

| Syntaxe | Qu'est-ce qui se passe |
|---------|------------------------|
| `dire` | Référence la fonction (pas d'exécution) |
| `dire()` | Exécute la fonction immédiatement |
| `dire('texte')` | Exécute la fonction avec un argument |
| `function() { dire('texte'); }` | Crée une nouvelle fonction qui exécute `dire('texte')` |

---

## Template de départ (CodePen)

Crée un nouveau pen sur https://codepen.io et copie-colle ceci :

**HTML :**
```html
<div id="demo">
  <h1>Mon premier projet interactif</h1>
  <button id="btn">Clique-moi</button>
  <p id="output"></p>
</div>
```

**CSS :**
```css
#demo {
  padding: 20px;
  font-family: sans-serif;
}

#btn {
  padding: 10px 20px;
  font-size: 16px;
  cursor: pointer;
}

#output {
  margin-top: 20px;
  color: #666;
}
```

**JavaScript :**
```javascript
const btn = document.getElementById('btn');
const output = document.getElementById('output');

btn.addEventListener('click', function() {
  output.textContent = 'Tu as cliqué!';
});
```

---

## L'œuvre : clickclickclick.click

Studio Moniker a créé [clickclickclick.click](https://clickclickclick.click/) — une expérience qui enregistre chaque clic de ta souris et affiche des statistiques.

C'est minimaliste mais puissant : en quelques clics, tu réalises que le site te *surveille*. Chaque mouvement, chaque clic est enregistré. C'est une critique de la collecte de données sur le web : on croit juste cliquer, mais on laisse une trace.

### Événements : détecter les actions de l'utilisateur

Pour que le site réagisse à tes clics (comme clickclickclick.click le fait), il faut **écouter les événements du navigateur**.

Les événements les plus courants :

```javascript
// Événements souris
element.addEventListener('click', function() {
  // Le bouton a été cliqué
});

element.addEventListener('mousemove', function(event) {
  // La souris se bouge. event.clientX et event.clientY donnent la position
});

element.addEventListener('mousedown', function() {
  // L'utilisateur appuie sur la souris
});

element.addEventListener('mouseup', function() {
  // L'utilisateur relâche la souris
});
```

L'objet `event` contient des infos sur ce qui s'est passé :
- `event.clientX, event.clientY` → position de la souris
- `event.target` → l'élément cliqué
- `event.type` → le type d'événement

**Exercice 4 :** Affiche la position de la souris
```javascript
document.addEventListener('mousemove', function(event) {
  const output = document.getElementById('output');
  output.textContent = 'X: ' + event.clientX + ', Y: ' + event.clientY;
});
```

---

### Les chaînes de caractères en JavaScript (string templates)

Quand tu veux construire du texte avec des variables, utilise les **template strings** :

```javascript
let count = 5;
let nom = 'Alice';

// Ancienne manière (concaténation)
const message1 = 'Bonjour ' + nom + ', tu as cliqué ' + count + ' fois';

// Nouvelle manière (template strings) — plus lisible
const message2 = `Bonjour ${nom}, tu as cliqué ${count} fois`;

console.log(message2); // "Bonjour Alice, tu as cliqué 5 fois"
```

Les template strings utilisent les **backticks** (`` ` ``) et les `${}` pour insérer des variables.

---

### Pratique : créer une version simplifiée de clickclickclick

Maintenant, crée un petit projet qui détecte les clics et affiche un compteur, comme l'idée de base de clickclickclick.

**Objectif :** Chaque fois que tu cliques n'importe où sur la page, un compteur augmente et s'affiche.

**Étapes :**

1. **Écoute les clics sur la page entière**
   ```javascript
   let clickCount = 0;

   document.addEventListener('click', function() {
     clickCount = clickCount + 1;
     console.log('Clics : ' + clickCount);
   });
   ```

2. **Affiche le compteur sur la page**
   ```javascript
   let clickCount = 0;
   const output = document.getElementById('output');

   document.addEventListener('click', function() {
     clickCount = clickCount + 1;
     output.textContent = `Tu as cliqué ${clickCount} fois`;
   });
   ```

3. **Ajoute des cas d'usage** (si tu as fini tôt)
   - Affiche aussi la **position** du clic (event.clientX, event.clientY)
   - Change la **couleur** du texte à chaque clic
   - Utilise `setTimeout()` pour **réinitialiser le compteur** après 5 secondes d'inactivité

---

## Stretch goals (pour les rapides)

### 1. Détecter les clics rapides

```javascript
let lastClickTime = 0;
const clickDelay = 300; // en millisecondes

document.addEventListener('click', function() {
  const now = Date.now();
  const timeSinceLastClick = now - lastClickTime;

  if (timeSinceLastClick < clickDelay) {
    output.textContent = 'Clic rapide !';
  }

  lastClickTime = now;
});
```

### 2. Réinitialiser après inactivité

```javascript
let inactivityTimer;

document.addEventListener('click', function() {
  // Annule le minuteur précédent
  clearTimeout(inactivityTimer);

  // Relance un minuteur de 3 secondes
  inactivityTimer = setTimeout(function() {
    output.textContent = 'Inactif...';
  }, 3000);
});
```

### 3. Créer une "chaleur" (heatmap basique)

Crée des petits carrés là où tu cliques :

```javascript
document.addEventListener('click', function(event) {
  const dot = document.createElement('div');
  dot.style.position = 'fixed';
  dot.style.left = event.clientX + 'px';
  dot.style.top = event.clientY + 'px';
  dot.style.width = '5px';
  dot.style.height = '5px';
  dot.style.backgroundColor = 'red';
  dot.style.borderRadius = '50%';
  document.body.appendChild(dot);
});
```

---

## Pièges courants

### 1. `getElementById()` retourne `null`

**Problème :**
```javascript
const btn = document.getElementById('btn');
btn.addEventListener('click', ...); // ERREUR: Cannot read property 'addEventListener' of null
```

**Causes possibles :**
- L'ID n'existe pas dans le HTML
- Le script s'exécute **avant que l'élément soit chargé** (voir section "Quand s'exécute le JavaScript")
- Typo dans l'ID (ex: `getElementById('button')` mais le HTML a `id="btn"`)

**Solution :** Vérifie que:
- L'ID est correct et unique dans la page
- Le script s'exécute **après** que l'élément soit créé
- La console (F12) te montre l'erreur exacte

---

### 2. Mélanger `textContent` et `innerHTML`

**Problème :**
```javascript
// Ceci ajoute du texte brut
btn.textContent = '<strong>Gras</strong>';  // Affiche littéralement: "<strong>Gras</strong>"

// Ceci ajoute du HTML
btn.innerHTML = '<strong>Gras</strong>';   // Affiche: **Gras** (en gras)
```

**Règle :**
- `textContent` = du texte simple, jamais du HTML
- `innerHTML` = du texte + balises HTML

Utilise `textContent` sauf si tu as vraiment besoin d'ajouter des balises.

---

### 3. Les accolades dans les template strings

**Erreur :**
```javascript
const count = 5;
const message = `Tu as cliqué ${count} fois`;  // ✅ Correct

// ❌ Ceci ne marche pas :
const message = "Tu as cliqué ${count} fois";  // Simple quotes, pas backticks
const message = 'Tu as cliqué ' + count + ' fois';  // Pas de ${} avec simple quotes
```

**Règle :** Les template strings utilisent **backticks** (`` ` ``), pas simple ou double quotes.

---

### 4. Oublier le `function()` dans `addEventListener`

**Erreur :**
```javascript
// ❌ Faux
btn.addEventListener('click', alert('Cliqué!'));

// ✅ Correct
btn.addEventListener('click', function() {
  alert('Cliqué!');
});
```

La deuxième argument doit être une **fonction**, pas l'appel d'une fonction.

Si tu veux passer une fonction qui a besoin de paramètres, fais ça:
```javascript
btn.addEventListener('click', function() {
  maFonction(parametre1, parametre2);
});
```

---

### 5. Modifier une variable et penser que ça change le DOM

**Erreur :**
```javascript
let message = 'Bonjour';
const output = document.getElementById('output');

message = 'Au revoir';
// Le DOM ne change pas! Tu as juste changé la variable.

// ✅ Correct
output.textContent = message;  // Là, le DOM change et ça s'affiche
```

**Règle :** Changer une variable JavaScript ne change pas automatiquement la page. Tu dois **explicitement modifier le DOM** avec `.textContent`, `.innerHTML`, `.style`, etc.

---

### 6. Event bubbling (un événement "remonte")

**Problème :**
```html
<div onclick="console.log('Div cliquée')">
  <button onclick="console.log('Bouton cliqué')">Clique-moi</button>
</div>
```

Quand tu cliques sur le bouton, tu vois :
```
Bouton cliqué
Div cliquée
```

Pourquoi? L'événement du bouton "remonte" à son parent (la div). C'est le **bubbling**.

**Solution :** Si tu veux empêcher ça :
```javascript
btn.addEventListener('click', function(event) {
  event.stopPropagation();  // Empêche l'événement de remonter
});
```

Mais **la plupart du temps, tu ne dois pas t'en soucier**. C'est un piège avancé.

---

### 7. Confondre `=` (assigner) et `==` (comparer)

**Erreur :**
```javascript
if (count = 5) {  // ❌ Assigne count à 5 au lieu de comparer
  console.log('C\'est 5');
}

if (count == 5) {  // ✅ Compare count avec 5
  console.log('C\'est 5');
}
```

**Règle :**
- Un seul `=` → assigne une valeur
- Deux `=` ou `===` → compare une valeur

Utilise `===` pour les comparaisons (c'est plus strict et sûr).

